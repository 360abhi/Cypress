+---------------------------+
| Cypress Test Runner       |  🖥️ Runs inside the browser
| - Executes commands       |
| - Hooks into DOM          |
| - Listens to events       |
+---------------------------+
         ⬇️ WebSocket Communication
+---------------------------+
| Cypress Backend (Node.js) |  💻 Runs outside the browser
| - Handles files, logging  |
| - Manages configs         |
| - Runs external plugins   |
+---------------------------+

Cypress commands (cy.visit(), cy.get(), etc.) are asynchronous, but Cypress does not use JavaScript promises directly. Instead, Cypress has its own command queue that ensures commands run in order.
Cypress commands don’t return values immediately like promises. Instead, Cypress automatically chains commands together.

We can use object destructuring while passing parameters in function where we want to pass in our order not the default one.

✅ Cypress Basics
Cypress Setup:

Installed Cypress and configured it with Node.
Familiarized with Cypress UI (npx cypress open).
Cypress Configuration: You learned how to set configurations like video recording and screenshots in the cypress.config.js file.
Cypress Commands:

describe and it blocks to structure tests.
Common Cypress commands like cy.visit(), cy.get(), cy.click(), and cy.type().
Understanding the Chai assertions (.should(), .contains(), .be.visible, etc.).
Running Tests:

Running tests using npx cypress run in headless mode.
Running a specific test file with --spec.
Running tests in headed mode (--headed).
Enabling video recording (--video).
Generate Mochawesome reports.
Running tests with custom configuration like baseUrl, timeouts, retries, etc.
Page Object Model (POM):

Created POM classes to structure your tests by defining elements (XPath or CSS selectors) and actions (methods).
Used the export default pattern for sharing classes and calling methods from the test scripts.
Troubleshooting:

Handled issues like element visibility and commands that sometimes failed to find elements.
Understood how to deal with waiting for elements and timeouts.
Test Reports & Screenshots:

You learned how to enable screenshots and videos for every test run.
Configured test reporting with the Mochawesome reporter.
✅ Key Cypress Commands Reviewed:
npx cypress open — Opens the Cypress UI.
npx cypress run — Runs tests in headless mode.
npx cypress run --spec "path/to/test-file.cy.js" — Runs a specific test file.
npx cypress run --headed — Runs tests in headed mode.
cy.get('selector') — Retrieves DOM elements.
cy.click() — Clicks on elements.
cy.type() — Types into form fields.
cy.visit() — Navigates to a webpage.
cy.xpath() — Queries elements using XPath (with cypress-xpath plugin).
cy.should() — Used for assertions (e.g., visibility checks).
cy.screenshot() — Takes a screenshot.
cy.wait() — Waits for elements or network requests.
What You’ve Mastered So Far:
Basic structure of Cypress tests.
How to interact with elements and assert conditions.
Setting up configuration options like videos, reports, and screenshots.
Using Page Object Model (POM) to manage test scripts effectively.
Running tests with specific configurations like --headed, --spec, and enabling video and report generation.
Understanding Cypress architecture and test execution flow.

BEFORE EACH: runs before every test
beforeEach() is a hook in Cypress that allows you to run some code before each test (it) in a test suite (describe). It’s commonly used to set up preconditions or repeat actions that you want to perform before every test.

describe('Login Tests', () => {
  // This will run before each test
  beforeEach(() => {
    cy.visit('https://example.com/login');  // Visit the login page
    cy.get('input[name="username"]').type('validUser');  // Type username
    cy.get('input[name="password"]').type('validPass');  // Type password
    cy.get('button[type="submit"]').click();  // Click login
  });

  it('should login successfully', () => {
    cy.url().should('include', '/dashboard');  // Assert that the URL includes 'dashboard'
  });

  it('should show the user dashboard', () => {
    cy.get('.dashboard').should('be.visible');  // Assert that the dashboard is visible
  });
});




🔹 Understanding cy.task() in Cypress
cy.task() is used to execute Node.js code outside of the browser environment.
Cypress runs tests inside the browser, but sometimes we need to:
✅ Read/write files (e.g., JSON, CSV, logs)
✅ Connect to a database
✅ Execute shell commands
✅ Call external APIs before or after tests
🔹 How it Works
You define a task function inside setupNodeEvents() in cypress.config.js.
Inside your test file (.cy.js), you call cy.task('taskName'), and Cypress runs it in Node.js (outside the browser).
The result is returned as a Promise, so you must use .then() to handle it.



🔥 Final Summary
Scenario	Cypress Command Needed?	Why?
cy.get('.title').invoke('text')	❌ No wrap needed	cy.get() returns a jQuery object, which supports .invoke().
cy.get('.title').each(el => el.invoke('text'))	❌ Will fail	el is a raw DOM element (not a Cypress command).
cy.get('.title').each(el => cy.wrap(el).invoke('text'))	✅ Wrap needed	cy.wrap(el) converts el into a Cypress command, making .invoke() work.


API ---------------->
The API is slow or unreliable.
You don’t want to hit a real backend while testing.
You need to test edge cases (e.g., server errors).

Mocking:
Replacing an actual API response with a fake response.
Helps in testing frontend behavior without depending on the real backend.
Stubbing:
Intercepting a network request and replacing it with custom data.
Can simulate different API scenarios like success, failure, or delays.

Parameters:
Parameter	Description	Example
method:	The HTTP method to intercept (GET, POST, PUT, DELETE, etc.).	'GET', 'POST'
url:	The API endpoint (can be full or partial match using wildcards).	'/api/users', '*api*'
response:	The mock response, can be an object ({}) or a function (req) => {}	{statusCode: 200, body: { name: 'John' } }


 Summary: What Can cy.intercept() Do?
✅ Mock API Responses → Return custom responses without calling the real server.
✅ Simulate API Failures → Test how UI handles 500, 400, or timeout errors.
✅ Modify Requests Dynamically → Change request/response data in real-time.
✅ Test Slow Networks → Simulate delay using setDelay().
✅ Intercept and Modify Any HTTP Method → GET, POST, PUT, DELETE, etc.

🚀 This allows Cypress to test frontend behavior without relying on real APIs! 🚀

🔍 req.reply() vs. Direct Response
Approach	Flexibility	When to Use
Direct Response (without a function)	✅ Simple and quick	When the response is always static
req.reply(callback) (with a function)	✅ Dynamic control over response	When you need to modify response based on request details

cy.intercept('GET', '/api/users', (req) => {
    req.reply((res) => {
        res.send({
            statusCode: 200,
            body: [{ id: 1, name: 'John Doe', time: new Date().toISOString() }]
        });
    });
}).as('dynamicUsers');


------------------
req.reply is alwasy used to modify the UI req
for post req sent to server modify use: req.body and send payload to it

---posts-----
When you intercept a POST request and want to inspect the response data, you will always use cy.wait() and then use .then() to access the interception. Here's why:

🎯 Why cy.wait() and then() are used with cy.intercept()
cy.wait(): It's needed to wait for the network request to complete before you proceed with your assertions or any other operations. The @ alias ensures that you're specifically waiting for that request (POST in this case).

.then(): You use this method to handle the interception object returned by the cy.wait(). This allows you to extract and work with interception.response.body or other response data.

deep_equal : inteception.request.body and interception.response.body

@@@@ Assertions in API
1. Status Code Assertions
Verify the HTTP status code (e.g., 200, 201, 400, 401, 404, 500).

2. Response Header Assertions
Check for specific headers (e.g., content-type, authorization).

Verify header values (e.g., application/json, Bearer token).

3. Response Body Assertions
Check if a property exists in the response.

Verify the value of a specific property.

Validate the data type of a property (e.g., string, number, boolean).

Check for nested properties in the response.

Verify the length of an array in the response.

Check if an array contains a specific object.

Validate partial matches in the response body.

Verify if a property value exists in an array.

4. Response Time Assertions
Ensure the response time is within an acceptable limit.

5. Error Response Assertions
Verify error messages in the response.

Check error codes or statuses.

Validate error details or descriptions.

6. Pagination Assertions
Verify pagination properties (e.g., page, pageSize, totalItems).

Check the length of the items array in paginated responses.

7. Schema Validation Assertions
Validate the response structure against a predefined schema.

8. Dynamic Data Assertions
Check if dynamic properties (e.g., IDs, timestamps) exist.

Validate dynamic values against patterns (e.g., email, UUID).

Verify if timestamps are recent or match expected formats.

9. Request Payload Assertions
Verify the request payload sent to the API matches expectations.

10. Query Parameter Assertions
Check if query parameters in the request are correct.

11. Authentication Assertions
Verify authentication headers (e.g., Authorization: Bearer token).

12. Response Size Assertions
Check the size of the response body (e.g., array length, byte size).

13. Empty Response Assertions
Verify if the response body is empty.

--------------------------------
